# Running prototype with the client application

We have designed a number of functions in JavaScript that can submit or evaluate transactions to the e-voting smart contract, namely for creating an election, querying it, submitting votes, closing the election, displaying the votes and evaluating the winner of the election.

## Enrolling the admin & users

Before we can execute the functions of the smart contract, we need to introduce the actors in our system. This is first the peers, who are each associated with a unique Certificate Authority administrator and provide MSP services. 

In our test network, there are 2 peers and we can set them up as follows:
```
$ cd client_application
$ node setup.js admin org1
$ node setup.js admin org2
```

Then, we need to register the other users in our network; these include the organizer of the election as well as a number of voters who will submit encrypted votes to the candidates. These are setup in our application as follows:
```
$ node setup.js organizer org1
$ node setup.js voter1 org1
$ node setup.js voter2 org2
```

With the entities in our network successfully registered and their wallets created, we can now execute the chaincode operations using our smart contract.

## Execution

To start off, the organizer can start a new election by invoking the CreateElection function in our smart contract, with the election name and the three candidates to vote for as function parameters. The chaincode then initializes a new election with the election name, candidates, ID of the organizer and placeholders to store the votes. Once the election is created, it is put into state using putState and the status of the election is set to open.

Let us create an example with an election titled 'Prime' that has 3 candidates: Ben, Simon and Josh.
```
// 1. Create a new election titled 'Prime'
$ node buildElection.js organizer org1 electionPrime ben simon jim
```

Once created, the election can be queried by invoking the QueryElection function in the smart contract, with the election name as parameter. The chaincode verifies the election exists and retrieves it from the blockchain state. 

While the election is open, peers can submit votes to the election by invoking SubmitVote transaction. The code snippet for this function, as implemented for SGX, can be found in Appendix C below. The chaincode generates a composite key to encrypt the vote (as explained in Section 4.1) and stores the data in the peerâ€™s private storage until the election is closed.

```
// 2. Voter submits a vote for candidate Ben
$ node addVote.js voter1 org1 electionPrime ben
--> Invoke e-voting chaincode: Add a new vote
--> Voter ID: CN=voter1
--> Result: Vote: 738dcfb07a4f2308677dca8c1d4ce6cb29197...
--> Result: OK
```

Upon submitting the vote to the election, a transaction ID is returned to the user by the smart contract and can be used by the voter to query their vote. This is because the transaction ID is used to re-construct the composite key that encrypted the vote. Additionally, querying the election confirms the hash of the vote in private storage is visible in the election. The votes remain hashed until the election is ended.

```
// 3. Query the vote submitted using the transaction ID
$ node queryVote.js voter1 org1 electionPrime 738dcfb07...
--> Invoke e-voting chaincode: Query vote
--> Result: Vote: {"voteFrom": "CN=voter1", "voteTo": "ben"}

// 4. Query the election to confirm vote was added
$ node queryElection.js organizer org1 electionPrime
--> Invoke e-voting chaincode: Get Election
--> Result: Election: {
    "name": "electionPrime",
    ...,
    "privateVotes": {
        "\u0vote\u0electionPrime\u0738dcfb07a4f...": {
            "hash": "9073790 a8a849ffb6a5f0475a53532e53f6..."
        }
    },
    "publicVotes": {},
    ...
}
```

The organizer can close the election by invoking the CloseElection function in the smart contract, taking election name as parameter. This prevents votes submitted thereafter from being counted and acts as an indicator for when displaying the votes to the public.

In order to display the votes, the smart contract will first check if the election is closed before confirming the hash generated by the composite key matches the hash of the private vote that is now present in the election. It will also confirm that the peer invoking this function was the one to submit the vote. Thereafter, the vote is visible to any entity querying the election.

```
// 5. Close the election 'Prime'
$ node closeElection.js organizer org1 electionPrime
--> Invoke e-voting chaincode: Close election
--> Result: OK

// 6. Let 'voter1' display his vote from earlier
$ node displayVote.js voter1 org1 electionPrime 738dcf07a...
--> Invoke e-voting chaincode: Make vote public
--> Result: Vote: {"voteFrom": "CN=voter1", "voteTo": "ben"}
--> Result: OK

// 7. Query the election 'Prime' to see the vote public
$ node queryElection.js organizer org1 electionPrime
--> Invoke e-voting chaincode: Get Election
--> Result: Election: {
    "name": "electionPrime",
    ...,
    "privateVotes": {
        "\u0vote\u0electionPrime\u0738dcfb07a4f...": {
            "hash": "9073790 a8a849ffb6a5f0475a53532e53f6..."
        },
    },
    "publicVotes": {
        "\u0vote\u0electionPrime\u0738dcfb07a4f...": {
            "voteFrom": "x509::CN=voter1...",
            "voteTo": "ben"
        }, 
    }, 
    ...
}
```

Once the election is closed and the votes have been displayed, the organizer can determine the candidate with the most number of votes and declare them the winner. This can be done by invoking EvaluateElection. The core logic of this smart contract function involves counting up the tallies for each candidate and finding the largest total with greater-lesser checks.

```
// 8. Determine the candidate with highest number of votes
$ node evaluateElection.js organizer org1 electionPrime
--> Invoke e-voting chaincode: Evaluate election
--> Result: The candidate with most votes is ben
--> Result: OK

$ node queryElection.js organizer org1 electionPrime
--> Invoke e-voting chaincode: Get Election
--> Result: Election: {
    "name": "electionPrime",
    ...,
    "publicVotes": {
        "\u0vote\u0electionPrime\u0738dcfb07a4f...": {
            "voteFrom": "x509::CN=voter1...",
            "voteTo": "ben"
        }
    },
    "winner": "ben",
    "numVotes": 1,
    "status": "completed"
}
```

In this way, we can run our smart contract accessing the client application through the terminal and passing along the required parameters for each function.